"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.usePopover = void 0;
var react_1 = require("react");
var util_1 = require("./util");
var useElementRef_1 = require("./useElementRef");
exports.usePopover = function (_a) {
    var childRef = _a.childRef, positions = _a.positions, containerClassName = _a.containerClassName, containerParent = _a.containerParent, align = _a.align, padding = _a.padding, boundaryTolerance = _a.boundaryTolerance, reposition = _a.reposition, boundaryInset = _a.boundaryInset, onPositionPopover = _a.onPositionPopover;
    var popoverRef = useElementRef_1.useElementRef(containerClassName, {
        position: 'fixed',
        overflow: 'visible',
        top: '0px',
        left: '0px',
    });
    var positionPopover = react_1.useCallback(function (positionIndex, childRect, popoverRect, parentRect) {
        var _a;
        if (positionIndex === void 0) { positionIndex = 0; }
        if (childRect === void 0) { childRect = childRef.current.getBoundingClientRect(); }
        if (popoverRect === void 0) { popoverRect = popoverRef.current.getBoundingClientRect(); }
        if (parentRect === void 0) { parentRect = containerParent.getBoundingClientRect(); }
        var isExhausted = positionIndex === positions.length;
        var position = isExhausted ? positions[positionIndex - 1] : positions[positionIndex];
        var _b = util_1.getNewPopoverRect({
            position: position,
            childRect: childRect,
            popoverRect: popoverRect,
            parentRect: parentRect,
            align: align,
            padding: padding,
            reposition: reposition,
        }, boundaryInset, boundaryTolerance), rect = _b.rect, boundaryViolation = _b.boundaryViolation;
        if (boundaryViolation && reposition && !isExhausted) {
            positionPopover(positionIndex + 1, childRect, popoverRect, parentRect);
            return;
        }
        var top = rect.top, left = rect.left, width = rect.width, height = rect.height;
        var finalTop = top;
        var finalLeft = left;
        if (reposition && !isExhausted) {
            (_a = util_1.getNudgedPopoverRect(rect, parentRect, boundaryInset, boundaryTolerance), finalTop = _a.top, finalLeft = _a.left);
        }
        popoverRef.current.style.transform = "translate(" + finalLeft + "px, " + finalTop + "px)";
        onPositionPopover({
            isPositioned: true,
            nudgedTop: finalTop - top,
            nudgedLeft: finalLeft - left,
            align: align,
            popoverRect: {
                top: finalTop,
                left: finalLeft,
                width: width,
                height: height,
                right: finalLeft + width,
                bottom: finalTop + height,
            },
            position: position,
            childRect: childRect,
            padding: padding,
            boundaryInset: boundaryInset,
            boundaryTolerance: boundaryTolerance,
        });
    }, [
        childRef,
        popoverRef,
        positions,
        align,
        padding,
        reposition,
        boundaryInset,
        boundaryTolerance,
        onPositionPopover,
        containerParent,
    ]);
    return [positionPopover, popoverRef];
};
//# sourceMappingURL=usePopover.js.map